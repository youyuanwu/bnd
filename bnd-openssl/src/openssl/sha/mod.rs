// Bindings generated by `windows-bindgen` 0.66.0

#![allow(
    non_snake_case,
    non_upper_case_globals,
    non_camel_case_types,
    dead_code,
    clippy::all
)]

windows_link::link!("crypto" "C" fn SHA1(d : *const u8, n : u64, md : *mut u8) -> *mut u8);
windows_link::link!("crypto" "C" fn SHA1_Final(md : *mut u8, c : *mut SHA_CTX) -> i32);
windows_link::link!("crypto" "C" fn SHA1_Init(c : *mut SHA_CTX) -> i32);
windows_link::link!("crypto" "C" fn SHA1_Transform(c : *mut SHA_CTX, data : *const u8));
windows_link::link!("crypto" "C" fn SHA1_Update(c : *mut SHA_CTX, data : *const core::ffi::c_void, len : u64) -> i32);
windows_link::link!("crypto" "C" fn SHA224(d : *const u8, n : u64, md : *mut u8) -> *mut u8);
windows_link::link!("crypto" "C" fn SHA224_Final(md : *mut u8, c : *mut SHA256_CTX) -> i32);
windows_link::link!("crypto" "C" fn SHA224_Init(c : *mut SHA256_CTX) -> i32);
windows_link::link!("crypto" "C" fn SHA224_Update(c : *mut SHA256_CTX, data : *const core::ffi::c_void, len : u64) -> i32);
windows_link::link!("crypto" "C" fn SHA256(d : *const u8, n : u64, md : *mut u8) -> *mut u8);
windows_link::link!("crypto" "C" fn SHA256_Final(md : *mut u8, c : *mut SHA256_CTX) -> i32);
windows_link::link!("crypto" "C" fn SHA256_Init(c : *mut SHA256_CTX) -> i32);
windows_link::link!("crypto" "C" fn SHA256_Transform(c : *mut SHA256_CTX, data : *const u8));
windows_link::link!("crypto" "C" fn SHA256_Update(c : *mut SHA256_CTX, data : *const core::ffi::c_void, len : u64) -> i32);
windows_link::link!("crypto" "C" fn SHA384(d : *const u8, n : u64, md : *mut u8) -> *mut u8);
windows_link::link!("crypto" "C" fn SHA384_Final(md : *mut u8, c : *mut SHA512_CTX) -> i32);
windows_link::link!("crypto" "C" fn SHA384_Init(c : *mut SHA512_CTX) -> i32);
windows_link::link!("crypto" "C" fn SHA384_Update(c : *mut SHA512_CTX, data : *const core::ffi::c_void, len : u64) -> i32);
windows_link::link!("crypto" "C" fn SHA512(d : *const u8, n : u64, md : *mut u8) -> *mut u8);
windows_link::link!("crypto" "C" fn SHA512_Final(md : *mut u8, c : *mut SHA512_CTX) -> i32);
windows_link::link!("crypto" "C" fn SHA512_Init(c : *mut SHA512_CTX) -> i32);
windows_link::link!("crypto" "C" fn SHA512_Transform(c : *mut SHA512_CTX, data : *const u8));
windows_link::link!("crypto" "C" fn SHA512_Update(c : *mut SHA512_CTX, data : *const core::ffi::c_void, len : u64) -> i32);
pub const SHA224_DIGEST_LENGTH: i32 = 28i32;
#[repr(C)]
#[derive(Clone, Copy, Default)]
pub struct SHA256_CTX {
    pub Value: SHA256state_st,
}
pub const SHA256_DIGEST_LENGTH: i32 = 32i32;
#[repr(C, packed(4))]
#[derive(Clone, Copy)]
pub struct SHA256state_st {
    pub h: [u32; 8],
    pub Nl: u32,
    pub Nh: u32,
    pub data: [u32; 16],
    pub num: u32,
    pub md_len: u32,
}
impl Default for SHA256state_st {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
pub const SHA384_DIGEST_LENGTH: i32 = 48i32;
#[repr(C)]
#[derive(Clone, Copy)]
pub struct SHA512_CTX {
    pub Value: SHA512state_st,
}
impl Default for SHA512_CTX {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
pub const SHA512_DIGEST_LENGTH: i32 = 64i32;
#[repr(C, packed(8))]
#[derive(Clone, Copy)]
pub struct SHA512state_st {
    pub h: [u64; 8],
    pub Nl: u64,
    pub Nh: u64,
    pub u: SHA512state_st_u,
    pub num: u32,
    pub md_len: u32,
}
impl Default for SHA512state_st {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(8))]
#[derive(Clone, Copy)]
pub union SHA512state_st_u {
    pub d: [u64; 16],
    pub p: [u8; 128],
}
impl Default for SHA512state_st_u {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Clone, Copy, Default)]
pub struct SHA_CTX {
    pub Value: SHAstate_st,
}
pub const SHA_DIGEST_LENGTH: i32 = 20i32;
pub const SHA_LBLOCK: i32 = 16i32;
#[repr(C, packed(4))]
#[derive(Clone, Copy)]
pub struct SHAstate_st {
    pub h0: u32,
    pub h1: u32,
    pub h2: u32,
    pub h3: u32,
    pub h4: u32,
    pub Nl: u32,
    pub Nh: u32,
    pub data: [u32; 16],
    pub num: u32,
}
impl Default for SHAstate_st {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
